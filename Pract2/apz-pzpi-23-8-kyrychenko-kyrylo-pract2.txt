МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ




ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмна інженерія»








ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
на тему «Методи рефакторингу коду програмного забезпечення на мові Java (Preserve Whole Object, Replace Parameter with Method, Consolidate Conditional Expression)»












Виконав:                                                                           Прийняв:
ст. гр. ПЗПІ-23-8                                                              Старший викладач каф. ПІ                                                                 
Кириченко К. В.                                                               Сокорчук І. П.






Харків 2025
________________
1 ІСТОРІЯ ЗМІН
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	09.11.2025
	0.1
	Створено відповідні розділи звіту
	

	

	

	

	

2 ЗАВДАННЯ
Якість програмного коду є ключовим фактором, що визначає довгострокову життєздатність будь-якого проєкту. З часом, під тиском нових вимог та змін, початкова архітектура системи може деградувати, що призводить до накопичення технічного боргу. Код стає заплутаним, складним для розуміння та крихким до змін. Для боротьби з цим явищем існує дисципліна рефакторингу – контрольований процес покращення внутрішньої структури коду, що не впливає на його зовнішню функціональність.
Основна мета рефакторингу – зробити код “чистішим”: більш читабельним, логічно структурованим та легким для подальшої підтримки. Це, у свою чергу, знижує ризик виникнення помилок при додаванні нових можливостей та прискорює процес розробки в цілому.
У даній роботі детально аналізуються три фундаментальні методи рефакторингу, кожен з яких вирішує типові проблеми в дизайні коду:
Preserve Whole Object (Збереження всього об'єкта): техніка, спрямована на спрощення сигнатур методів та зменшення кількості параметрів.
Replace Parameter with Method Call (Заміна параметра викликом методу): метод для покращення інкапсуляції та переміщення логіки обчислень у відповідне місце.
Consolidate Conditional Expression (Консолідація умовного виразу): підхід до спрощення заплутаної умовної логіки для підвищення її прозорості.
Для демонстрації практичного застосування цих технік використовуються приклади, реалізовані мовою програмування Java.
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Метод Preserve Whole Object (Збереження всього об'єкта)
Метод Збереження всього об'єкта застосовується, коли з об’єкта отримується кілька значень, які потім передаються як параметри в інший метод. Рефакторинг полягає в тому, щоб передавати весь об’єкт цілком.
Причини рефакторингу:
* довгий список параметрів у виклику методу, що погіршує читабельність;
* параметри логічно пов’язані, оскільки є частиною одного об’єкта;
* при додаванні нового поля в об’єкт-джерело доводиться змінювати сигнатуру методу, що його використовує.
Переваги:
* скорочує список параметрів, роблячи виклик методу чистішим;
* код стає більш стійким до змін: якщо методу знадобиться ще одне поле з об’єкта, його сигнатуру не доведеться змінювати.
Недоліки:
* метод стає залежним від структури класу-контейнера, що збільшує зв’язаність (coupling) між класами.
Порядок рефакторингу:
1. у методі, що рефакториться, створюється новий параметр, який прийматиме весь об’єкт;
2. у коді методу використання старих параметрів замінюється на звернення до відповідних полів (через геттери) об’єкта, що передається;
3. знаходяться всі виклики цього методу та змінюються: замість набору значень передається вихідний об’єкт;
4. після оновлення всіх викликів, старі параметри видаляються з оголошення методу.


До рефакторингу:
1 class HeatingPlan {
2     private int low;
3     private int high;
4     // конструктор, геттери...
5 }
6 
7 class Room {
8     public boolean isWithinPlan(int temperature, int low, int high) {
9         return temperature >= low && temperature <= high;
10    }
11 }
12 
13 // Виклик методу
14 HeatingPlan heatingPlan = new HeatingPlan(18, 24);
15 room.isWithinPlan(22, heatingPlan.getLow(), heatingPlan.getHigh());


Після рефакторингу:
1 class HeatingPlan {
2     private int low;
3     private int high;
4     // конструктор, геттери...
5 }
6 
7 class Room {
8     public boolean isWithinPlan(int temperature, HeatingPlan plan) {
9         return temperature >= plan.getLow() && temperature <= plan.getHigh();
10    }
11 }
12 
13 // Виклик став значно чистішим
14 HeatingPlan heatingPlan = new HeatingPlan(18, 24);
15 room.isWithinPlan(22, heatingPlan);


Виклик методу isWithinPlan став значно коротшим і зрозумілішим. Залежність тепер передається через один об’єкт HeatingPlan, а не через набір примітивних значень.
3.2 Метод Replace Parameter with Method Call (Заміна параметра викликом методу)
Цей метод полягає у видаленні параметра, значення якого може бути обчислене всередині самого методу шляхом виклику іншого методу.
Причини рефакторингу:
* код, що викликає метод, змушений виконувати підготовчу роботу (обчислення), яка логічно належить самому методу;
* видалення параметра спрощує виклик методу і зменшує дублювання коду, якщо цей параметр обчислюється в кількох місцях.
Переваги:
* покращує інкапсуляцію: метод стає більш самодостатнім і приховує деталі обчислень;
* зменшує дублювання коду, оскільки логіка обчислень знаходиться в одному місці.
Недоліки:
* може незначно вплинути на продуктивність, якщо обчислення є складним і викликається часто;
* збільшує зв’язаність, якщо для обчислення методу потрібен доступ до іншого об’єкта.


Порядок рефакторингу:
1. якщо код для обчислення параметра ще не є окремим методом, застосувати до нього рефакторинг «Виділення методу»;
2. всередині методу, що рефакториться, викликати метод обчислення і присвоїти результат локальній змінній, яка замінить старий параметр;
3. поступово, один за одним, знайти виклики старого методу і видалити з них параметр, що обчислюється;
4. після оновлення всіх викликів, видалити параметр з оголошення методу;


До рефакторингу:
1 class Order {
2     private double basePrice;
3     private int discountLevel;
4     // конструктор, геттери...
5 
6     public double getFinalPrice(double discountedPrice) {
7         return discountedPrice + 50; // Додаємо вартість доставки
8     }
9 }
10 
11 // Виклик
12 Order order = new Order(1000, 2);
13 double discountedPrice = order.getBasePrice() - (order.getDiscountLevel() * 100);
14 double finalPrice = order.getFinalPrice(discountedPrice);


Після рефакторингу:
1 class Order {
2     private double basePrice;
3     private int discountLevel;
4     // конструктор, геттери...
5 
6     private double getDiscountedPrice() {
7         return this.basePrice - (this.discountLevel * 100);
8     }
9 
10    public double getFinalPrice() {
11        // Метод сам обчислює потрібне значення
12        return getDiscountedPrice() + 50;
13    }
14 }
15 
16 // Виклик став простішим
17 Order order = new Order(1000, 2);
18 double finalPrice = order.getFinalPrice();


Логіка розрахунку знижки тепер інкапсульована всередині класу Order. Код, що викликає, став чистішим і не переймається деталями обчислень.
3.3 Метод Consolidate Conditional Expression (Консолідація умовного виразу)
Метод полягає в об'єднанні кількох умовних перевірок, що ведуть до однакового результату, в один умовний вираз за допомогою логічних операторів.
Причини рефакторингу:
* кілька послідовних умовних перевірок ускладнюють розуміння загальної логіки;
* об’єднану умову легше виділити в окремий метод, що покращує читабельність;
Переваги:
* покращує читабельність та ясність коду: одна складна перевірка зрозуміліша за кілька простих;
* зменшує дублювання коду, якщо дія в умовних блоках повторюється;
* допомагає виявити та виділити складну логіку в окремі методи з промовистими назвами.
Порядок рефакторингу:
1. переконатися, що умовні перевірки не мають “побічних ефектів” (тобто не змінюють стан програми);
2. створити один умовний оператор, об’єднавши всі умови за допомогою логічних операторів && та ||;
3. перенести дію, що виконувалася в усіх старих умовах, у новий об'єднаний блок if;
4. видалити попередні умовні блоки;
5. (опціонально) розглянути можливість виділення нової складної умови в окремий метод.


До рефакторингу:
1 class Employee {
2     // поля: isOnVacation, seniority, isPartTime, baseSalary...
3     // геттери...
4 }
5 
6 public double calculateDisabilityAmount(Employee employee) {
7     if (employee.isOnVacation()) {
8         return 0;
9     }
10    if (employee.getSeniority() < 1) {
11        return 0;
12    }
13    if (employee.isPartTime()) {
14        return 0;
15    }
16    // ... складна логіка розрахунку
17    return employee.getBaseSalary() * 0.8;
18 }




Після рефакторингу:
1 class Employee {
2     // ...
3 }
4 
5 public double calculateDisabilityAmount(Employee employee) {
6     if (employee.isOnVacation() || employee.getSeniority() < 1 || employee.isPartTime()) {
7         return 0;
8     }
9     // ... складна логіка розрахунку
10    return employee.getBaseSalary() * 0.8;
11 }

        Замість трьох окремих if тепер використовується один, що робить логіку перевірки умов для відмови у виплаті миттєво зрозумілою.
4 ВИСНОВКИ
В ході виконання даної роботи було на практиці досліджено три ефективні методи рефакторингу: Preserve Whole Object, Replace Parameter with Method Call та Consolidate Conditional Expression. Кожен з них, хоч і вирішує різні завдання, має спільну кінцеву мету – підвищення якості та підтримуваності програмного коду.
Аналіз показав, що такі техніки, як Preserve Whole Object та Replace Parameter with Method Call, працюють на рівні інтерфейсів класів та методів. Вони дозволяють спростити взаємодію між об’єктами, покращити інкапсуляцію та знизити зв'язаність (coupling), що робить систему більш гнучкою до змін. Код стає не тільки чистішим, але й більш інтуїтивно зрозумілим для розробників, які будуть з ним працювати.
З іншого боку, метод Consolidate Conditional Expression фокусується на покращенні внутрішньої логіки методів. Він дозволяє перетворити заплутані та розрізнені перевірки на єдину, прозору умову. Це не тільки покращує читабельність, але й є першим кроком до виділення складної бізнес-логіки в окремі, добре іменовані методи, що робить код самодокументованим.
Застосування цих методів на практичних прикладах мовою Java продемонструвало, що рефакторинг є гарним інструментом та робить процес розробки більш передбачуваним та ефективним у довгостроковій перспективі.












































________________


ВИКОРИСТАНІ ДЖЕРЕЛА


1. Refactoring Techniques. URL:  https://refactoring.guru/refactoring/techniques (дата звернення: 09.11.2025).
2. Фаулер, Мартін. Refactoring: Improving the Design of Existing Code (2nd Edition), 2018 (дата звернення: 09.11.2025).










































________________


ДОДАТОК А
Посилання на Youtube відеозапис
https://youtu.be/p05kz1fHHCY
















































________________


ДОДАТОК Б
Слайди презентації


  

Рисунок 1 – Титульний слайд


  

Рисунок 2 – Слайд теорії. Рефакторинг
  

Рисунок 3 – Слайд методу: Збереження всього об’єкта. Preserve Whole Object


  

Рисунок 4 – Слайд порядку рефакторингу методу Preserve Whole Object






  

Рисунок 5 – Слайд прикладу методу Preserve Whole Object


  

Рисунок 6 – Слайд метода: Заміна параметра викликом методу. Replace Parameter With Method Call 




  

Рисунок 7 – Слайд порядку рефакторингу методу Replace Parameter With Method Call 


  

Рисунок 8 – Слайд прикладу методу Replace Parameter With Method Call 




  

Рисунок 9 – Слайд методу: Консолідація умовного виразу. Consolidate Conditional Expression


  

Рисунок 10 – Слайд порядку рефакторингу методу Consolidate Conditional Expression


  

Рисунок 11 – Слайд прикладу методу Consolidate Conditional Expression


  

Рисунок 12 – Слайд висновків


  

Рисунок 13 – Слайд використаних джерел